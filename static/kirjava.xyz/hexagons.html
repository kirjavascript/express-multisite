<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width" />
        <title>Hexagons</title>
        <style>
            body {
                margin: 0;
                height: 100%;
            }
            canvas {
                position: absolute;
                overflow: hidden;
                cursor: all-scroll;
                left: 0;
                top: 0;
                z-index: 0;
            }
        </style>
    </head>
    <body>

        <canvas></canvas>
        <script>

function hexagon(x, y, size, length = 7) {
    const chord = Math.PI / 3;
    return Array.from({ length }, (_, i) => [
        x + Math.sin(i * chord) * size,
        y + Math.cos(i * chord) * size,
    ]);
}

const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

const measure = (points, indexA, indexB, type) => points[indexA][type] - points[indexB][type];
const getHexWidth = (points) => measure(points, 1, 4, 0);
const getHexHeight = (points) => measure(points, 1, 3, 1);

const epoch = performance.now();
const mouse = drag();
const cubes = [];

(function loop() {
    requestAnimationFrame(loop);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'bevel';

    const drawLayer = (x, y, size, adjustCtx) => {
        const initial = hexagon(0, 0, size)
        const hexWidth = getHexWidth(initial);
        const hexHeight = getHexHeight(initial);
        // we only draw half a hexagon each time, so need quite a bit of overscroll
        const quantityX = Math.floor(canvas.width / hexWidth) + 5;
        const quantityY = Math.floor(canvas.height / hexHeight) + 5;

        const drawLine = (x, y) => {
            const offset = x % hexWidth;
            for (let i = 0; i < quantityX; i++) {
                const points = hexagon(((i - 2) * hexWidth) - offset, y, size, 4);
                ctx.beginPath();
                adjustCtx && adjustCtx(ctx);
                points.forEach(([x, y]) => ctx.lineTo(x, y));
                ctx.stroke();
            }
        };

        for (let i = 0; i < quantityY; i++) {
            const offsetX = - (i % 2) * hexWidth / 2;
            const offsetY = y % (hexHeight * 2);
            drawLine(offsetX - x, ((i - 2) * hexHeight) + offsetY);
        }
    };

    const t = performance.now() - epoch;

    // mouse.x += 1;
    // mouse.y += Math.sin(t / 1e3);

    mouse.render();

    drawLayer(mouse.x, mouse.y, 50, (ctx) => {
        ctx.strokeStyle = 'cyan';
        ctx.lineWidth = 5;
    });

    drawCubes();

    drawLayer(mouse.x * 2,mouse.y * 2, 100, (ctx) => {
        ctx.strokeStyle = 'steelblue';
        ctx.lineWidth = 10;
    });

    document.title = String.fromCharCode(5e5 + ((t ^ 0x7F) % 0x7F)); // TODO: favicon
})();

function drag() {
    let lastX, lastY, down

    const mouse = {
        x: 0, y: 0, vx: -20, vy: 10,
        render: () => {
            mouse.x += mouse.vx;
            mouse.y += mouse.vy;
            if (!down) {
                mouse.vx *= .95;
                mouse.vy *= .95;
            }
        },
    };

    const setPos = (e) => [
        lastX, lastX = e.offsetX / 5,
        lastY, lastY = e.offsetY / 5,
    ];

    canvas.addEventListener('mousedown', e => {
        down = true;
        setPos(e);
    });

    canvas.addEventListener('mousemove', e => {
        if (down) {
            const [lastX, x, lastY, y] = setPos(e);
            mouse.vx = x - lastX;
            mouse.vy = y - lastY;
        }
    });

    const end = (e) => { down = false; };
    canvas.addEventListener('mouseup', end);
    canvas.addEventListener('mouseout', end);

    return mouse;
}

function getScreenCenter() {
    const dimensions = hexagon(0, 0, 50);
    const hexWidth = getHexWidth(dimensions);
    const hexHeight = getHexHeight(dimensions);
    const centerX = hexWidth * (0 | canvas.width / hexWidth / 2);
    const centerY = hexHeight * (0 | canvas.height / hexHeight / 2);
    return [centerX, centerY];
}

function getCubeCenter(points) {
    const [[x0, y0], one, two, [x1, y1]] = points;
    return [x0, y0 - ((y0 - y1) / 2)];
}

function lerp(start, end, i) {
    return start + (end - start) * i;
}

function drawCubes() {
    if (!cubes.length) {
        const [centerX, centerY] = getScreenCenter();
        const dimensions = hexagon(0, 0, 50);
        const hexWidth = getHexWidth(dimensions);
        const cubeHeight = measure(dimensions, 4, 3, 1) * 1.04; // give some extra space for stroke width

        const K = [[3, -3], [3, -1], [3, 1], [5, 1], [7, 1], [0, 0], [1, 1], [2, 2], [3, 3], [4, 4]];

        [...K.map(([x, y]) => [x, y + 2]), ...K]
            .forEach(([offsetX, offsetY], i) => {
                const x = centerX + (hexWidth / 2 * offsetX);
                const y = centerY + (cubeHeight * offsetY);
                const color = 0 | Math.random() * 360;
                cubes.push({ x, y, color, dx: 0, dy: -centerY, vx: 0, vy: - i });
            });

        // cubes.push({ x: centerX, y: centerY, color, dx: 0, dy: -centerY, vx: 0, vy: 5 });
    } else {
        // TODO: bounce off screen based on mouse vel

        cubes.forEach(cube => {
            cube.vy += 0.9;
            cube.dy = Math.min(0, cube.dy + cube.vy);

            const { color, x, y, dx, dy } = cube;
            const points = hexagon(mouse.x + x + dx, mouse.y + y + dy, 50);

            const i = 1 - (Math.min(500, dy) / -500);
            const fill = `hsl(${color},100%,${lerp(75, 100, i)}%)`;
            const stroke = `hsl(${color},${lerp(100, 0, i)}%,${lerp(25, 10, i)}%)`;
            ctx.beginPath();
            points.forEach(([x, y]) => ctx.lineTo(x, y));
            ctx.fillStyle = fill;
            ctx.fill();
            ctx.lineWidth = 7;
            ctx.strokeStyle = stroke;
            ctx.stroke();
            ctx.closePath();
            ctx.beginPath();
            points[3] = getCubeCenter(points); // sneaky
            points.forEach(([x, y]) => ctx.lineTo(x, y));
            ctx.fillStyle = stroke;
            ctx.fill();

        });
    }
}
